По русски обобщения, но все называют дженерики.

Дженерики нужны, чтобы передавать тип или несколько типов - как аргумент. И после задействовать тип как переменную
Gen<T> {
T o;
}

Gen<Integer> ob1 = new Get<Integer>(new Integer(88));
Gen<Integer> ob1 = new Get<Integer>(88);
Gen<Integer> ob1 = new Get<>(88);

Дженерики передают параметризованный тип. Тип как аргумент и параметр.
Нужны чтобы 1) Использовать один код для разных данных 2)обеспечивать контроль и безопасность типов
Часто применяется в универсальных коллекциях

Разные версии параметризованного класса не создаются. При компиляции, компилятор удаляет информацию о обобщенном типе, проставляет тип Object и делает приведение типов (называет очистка).

Параметризованный тип должен ссылаться на класс, не может быть примитивным типом как int или byte.
Ссылки на разные дженерики одного класса несовместимы между собой.
Параметров типа может быть больше одного.
class TwoGen<T,V> {}

Параметр типа может быть ограничен:
class Gen<T extends Numbers> суперкласс опеделяет верхнюю границу в иерархии классов (включая его самого).

Шаблон аргумента (wildcard) <?> определяет неизвестный тип. Он используется, когда нужна манипуляция с дженериком того же класса с другим параметризованным типом.
Шаблон можно ограничивать сверху <? extends суперкласс>
Шаблон можно ограничивать снизу <? super подкласс>

Обобщенные методы могут быть объявлены в необобщенном классе.
<T extends Numbers> void funName(T a) {}
Обобщенный конструктор может быть в необобщенном классе.

Так же могут быть объявлены обобщенные интерфейсы. Классы, которые их реализуют так же должны быть объявлены обобщенными, либо при объявлении класса должен быть указан конкретый тип парамерта для имплементируемого интерфейса.

Дженерики объявленные без указания аргумента создают сырой (базовый) тип. Это нужно для совместимости со старыми программами. При этом утрачивается безопасность типов.

С версии JDK7 появилась укороченная запись
Gen<Integer> t = new Gen<>(); справа не нужно повторно указывать тип, т.к. происходит автоматическое определение типов (в т.ч. для аргументов)

Как работает очистка: при компиляции все сведения об обобщенных типах удаляются, типы заменяются на Object или класс верхней границы. Далее делается приведение типов заданных аргументами типа.

Ошибки неодназначности:
) Нельзя задавать тип статических чл. класса через дженерики
) Нельзя создавать новые объекты через new с типом из параметра
) Нельзя создать массив с данными обобщенного типа
) Обобщенный класс не может расширять Throwable







