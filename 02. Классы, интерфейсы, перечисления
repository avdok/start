
Класс - это шаблон по которому создается объект. Появляется в памяти, когда создается объект. Представляет какую-то одну логическую сущность.

Класс определяет поля (переменные) и методы (функции). Если программа начинает выполнение с класса, в нем должен быть определен статический метод main().
К полям и методам можно обращаться через точку, если они доступны.

Класс создается путем объявления переменной типа класса и вызовом констрктора Student vasya = new Student()

Методы должны определять возвращаемое значение (если ничего, то void), за исключением конструкторов. Возврат из метода через завершение тела } или return возвр_зн.
У методов могут быть определены аргументы.

Класс содержит неявный конструктор, который можно определить явно. Конструктор - метод который выполняется при создании объекта. Конструкторов может быть много - они будут содержать разное количество и тип аргументов. Конструктор может вызвать конструктор предка класса используя ключевое слово super. Если конструктор содержит параметры, то при создании объекта нужно передать аргументы перем = new ИмяКласса(параметр1, параметр2);

Объекты явным образом не удаляются. Их удаляет сборщик мусора. Перед окончательный удалением объекта из памяти вызывается метод finalize который можно переопределить protected void finalize() {}. Возможно, что он не успеет вызваться, т.к. программа завершится раньше, чем будет вызван сборщик мусора. Может быть использован, например, чтобы закрыть открытые на чтение файлы.

Ключевое слово this - указывает на текущий объект. Через точку позволяет обращаться к его полям и методам. Например, если в текущей области видимости переопределены глобальные поля класса.

Члены класса (поля и методы) могут содержать модификатор доступа: public, private или protected.
public - чл. класса доступен везде и всем.
private - чл. класса доступен только внутри класса (недоступен в дочернем классе)
protected - чл. класса доступен другим классам в пакете или подклассам.
Если модификатор доступа отсутствует, то чл. класса доступен всем внутри пакета.

Чл. класса могут определяться со словом static. Обращаться к таким чл. класса нужно через имя класса и точку. Так могут быть заданы глобальные переменные. Статические методы могут непосредственно обращаться только к статическим полям и методам.

Статический блок static {} вызывается при первой загрузке класса. Там могут устанавливаться сетевое соединение, поводиться инициализация и т.д.

Статическим классом может быть только внутренний класс.
Методу можно передавать неопределенное число аргументов int method(int ... v) {}. v - фактически массив параметров переменной длины. Указывается последним и только один раз в списке параметров одного метода. Методы с переменным количеством параметров можно перегружать.

В случае перегрузки методов с неопределенным количеством параметров может возникать ситуация неопределенности. В таком случае компилятор выдаст ошибку.

Метод может быть абстрактным. В таком случае не описывается реализация этого метода, только тип возвращаемого значения и сигнатура abstract void method(int i);
Если класс содержит один или несколько абстрактных методов, то он должен быть объявлен абстрактным. На основе абстрактного класса нельзя создать объекты, его можно только наследовать.
Реализация всех абстрактных методов должна быть определена в дочернем классе. Если в дочернем классе не определена реализация абстрактного метода родительского класса, то дочерний класс так же должен быть объявлен абстрактным.
Спецификатор abstract не может быть применен для конструкторов и статических методов.


Интерфейсы определяются как абстрактные классы, но не содержат ни одного метода с реализацией.
Интерфейс определяется с модификатором доступа public или без него:
interface A {}

Переменные в интерфейсе неявно определены с модификаторами public static final. Т.е. являются константами. И не могут быть переменными экземпляра.

Классы наследуют интерфейс: class Classe implements InterfaceA, InterfaceB {}
Если класс не описывает реализацию всех методов интерфейса, то его необходимо объявить абстрактным.

Интерфейс можно указать в качестве типа переменной, которая может содержать ссылку на объекты любого класса реализующего этот интерфейс.

Одно из применений интерфейса - хранить глобальные константы, которые можно использовать в любом классе, имплементировав их туда.

Интерфейс по аналогии с классом может наследовать другой интерфейс: interface B extends A {}

В JDK8 появилась возможность определять релаизацию в интерфейсе методов по умолчанию (методы расширения). Используется модификатор default.
default void method(int a) {реализация}
Обращение через super: A.super.method();

В JDK8 можно определить один или несколько статических методов в интерфейсе. Вызываются через имя интерфейса и точку.
InterfaceA.methodB();
Статические методы не наследуются (ни дочерними классами, ни дочерними интерфейсами)

Перечисления содержат в себе набор констант
enum Transport {
    CAR, BOAT, AIRPLANE
}
Константы неявно задаются как static public

Transport tp =  Transport.CAR;

Метод values() - возвращает массив элементов перечисления
Метод valuesof(String str) - возвращает константу соответствующую строке в параметре

У перечисления могут быть определены поля, методы и конструктор.
enum Transport {
    //само перечисление, для каждого элемента вызывается конструктор с параметром
    CAR(10), BOAT(20), AIRPLANE(100);
    
    public int speed;
    
    Transport(int s) {
        speed = s;
    }
    
    public int getSpeed() {
        return speed;
    }
    
    public void setSpeed(int s) {
        speed = s
    }
}







